To address the software engineering design principles, we altered many areas of the code in order to make it more simple and understandable for anyone reading it. To do this, we improved the overall design smell of the code by addressing a few key aspects. 

The first aspect we considered was immobility. To do this, we changed the data structures in the way our data was stored in our code. Previously, it was hard to store and update certain information, meaning that it would make it difficult to update certain data across all the different functions. This meant that in the later iterations, the code we had previously written would be too difficult to use. By making our data structure a list of dictionaries, it eliminated the problem as it allowed us to store and update important information by using the append function. This allowed more of the data to be stored more efficiently for use in other functions later on. 

Another aspect we addressed was the issue of opacity. In the second iteration, we constructed our code so that each individual function would be successfully implemented, but we did not consider too much about how to link the functions together. This made it harder for the other members to understand each other’s code, as there were many different coding styles and complex loops. As a result, we had to minimise the complex loops in our code so that it was easier to understand for the other group members. To do this, we had two members review the code and to fix and comment the code using a uniform coding style. This way it made it easier for each member to understand. 

The third aspect we looked at was avoiding needless complexity. As each member worked on their own part for iteration 2, we didn’t pay too much attention to the help function, and as a result each individual’s functions weren’t unified. This meant that, for example, when calling functions, it became much harder to do and would involve needless complex calls. As a result, to fix this, we put all the functions in one place, so that we could use it as a team. This helped to remove the needless complexity that arose from working individually in iteration 2. At the same time, this also fixed the coupling issue, whereby in the previous iterations, interdependent functions were hard to implement together since each member worked on a separate portion. After fixing these, calling on interdependent functions became a lot easier to do. 

The final aspect we altered was the needless repetition of some areas of our code. In certain functions where there were very close similarities in the functions, we had repeated lines of code which we could have eliminated by constructing helper functions outside the main functions. After doing this, we eliminated a lot of lines of code which had been repeated and had made the code look more complicated than it actually was. As a result, the code become more readable and understandable as there were less lines. 

By improving these areas of our code, we made it more maintainable as it was much less complex and easier to read. We also made it more understandable as in the end each member was able to easily understand how the code worked. Finally, we made the code more testable as, again, the complexity was much lower meaning that any errors could be identified more easily. By keeping the code simple and easy to understand, we also satisfied the ‘KISS’ principle.
